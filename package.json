{
  "name": "api-server",
  "version": "1.0.0",
  "description": "Dynamic API Phase 3: Add Database Abstraction and Associations to your API  Today’s lab adds no new requirements to the API server. Our goal today is to swap out the route handler functions in favor of a Collection Interface which will consume a Sequelize Model and perform generic Database CRUD operations. You should consider this a “refactor” of your previous assignment, but treat this as a new build – do not simply copy your previous files and start working. Rebuild the server, re-asserting your knowledge of how it works, how it’s architected, and how to operate it.Build a REST API using Express, by creating a proper series of endpoints that perform CRUD operations on a Postgres SQL Database, using the REST standard",
  "main": "index.js",
  "scripts": {
    "start": "NODE_ENV=production node index.js",
    "test": "NODE_ENV=test jest"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/MarahAlrefaai/api-server.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/MarahAlrefaai/api-server/issues"
  },
  "homepage": "https://github.com/MarahAlrefaai/api-server#readme",
  "devDependencies": {
    "supertest": "^6.2.2"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.0.0",
    "express": "^4.17.3",
    "jest": "^27.5.1",
    "pg": "^8.7.3",
    "psql": "^0.0.1",
    "sequelize": "^6.17.0",
    "sqlite3": "^5.0.2",
    "test": "^0.6.0"
  }
}
